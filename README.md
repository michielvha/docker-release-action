# Docker Release Action

A reusable GitHub Action that builds and publishes Docker images with version detection via environment variables.

## Features

- üê≥ Docker image building and pushing to Docker Hub
- üèóÔ∏è Multi-platform support (configurable)
- üîÑ Reusable across multiple repositories
- üè∑Ô∏è Automatic tagging with version, latest, and SHA
- ‚ö° Simple and clean - no complex configuration needed
- üéØ Works seamlessly with GitVersion environment variables

## How It Works

This action builds and pushes Docker images with flexible versioning options. You can either:
- Provide a specific version using the `version` input parameter
- Use GitVersion by using the output generated by our other custom action as input
- Use the default 'dev' version for development builds

The action creates three Docker tags:
- **Version tag**: `username/project:{version}`
- **Latest tag**: `username/project:latest`  
- **SHA tag**: `username/project:abc123...`

## Usage

### Basic Example

A minimal viable example can be found [here](./examples/minimal.yaml)

### Prefered workflow

This is my personal prefered implementation, combining automated versioning with easy docker release, requires only 2 files and a repository secret. This can be automated with repo templates and variable groups. Check out the example [here](./examples/main.yaml)

## Example Repository Structure

The actions assumes the following structure as default. You can specify the `Dockerfile` location using the `context` input parameter.

```
your-repo/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ release.yml
‚îú‚îÄ‚îÄ app/...
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ gitversion.yml
‚îî‚îÄ‚îÄ README.md
```

## Example Dockerfile

the following is an example dockerfile that sets the image name as the project name.

```Dockerfile
FROM alpine:latest

# Set build-time variable, imported from pipeline environment during `Build` step
ARG IMAGE_NAME
# Copy the ARG value to an ENV variable that will persist at runtime
ENV IMAGE_NAME=${IMAGE_NAME}

# Create a non-root user with a fixed UID and group ID
RUN addgroup -g 1000 ${IMAGE_NAME} && \
    adduser -D -u 1000 -G ${IMAGE_NAME} ${IMAGE_NAME}

# Copy the binary into the container and adjust permissions
COPY ${IMAGE_NAME} /usr/local/bin/${IMAGE_NAME}
RUN chmod +x /usr/local/bin/${IMAGE_NAME} && chown ${IMAGE_NAME}:${IMAGE_NAME} /usr/local/bin/${IMAGE_NAME}

# Switch to the non-root user
USER ${IMAGE_NAME}

# Use shell form to allow variable substitution
ENTRYPOINT /usr/local/bin/${IMAGE_NAME}
```

## Inputs

| Input | Description | Required | Default |
|-------|-------------|----------|---------|
| `version` | GitVersion version to use | ‚ùå | `dev` |
| `username` | Docker Hub username | ‚úÖ | - |
| `password` | Docker Hub password or token | ‚úÖ | - |
| `project` | Docker image name (e.g., edgeforge/erm) | ‚úÖ | - |
| `platforms` | Target platforms for Docker build | ‚ùå | `linux/amd64` |
| `context` | Docker build context | ‚ùå | `.` |

## Outputs

| Output | Description |
|--------|-------------|
| `image-digest` | Docker image digest |

## Generated Tags

This action automatically generates the following Docker tags:

1. **Version Tag**: `{username}/{project}:{version}`
2. **Latest Tag**: `{username}/{project}:latest`
3. **SHA Tag**: `{username}/{project}:{github.sha}`

The `version` can be:
- A specific version string (e.g., "1.2.3")
- The GitVersion semantic version using `${{ env.GITVERSION_SEMVER }}`
- The default "dev" for development builds

## Prerequisites

### 1. Docker Hub Secrets

Add this secrets to your repository:

- `DOCKER_PASSWORD`: Your Docker Hub password or access token

optionally create an repo variable for `DOCKER_USERNAME` or just hardcode it in the workflow

### 2. GitVersion Setup (Optional)

If you want to use GitVersion for automatic semantic versioning, use this action to set the `GITVERSION_SEMVER` environment variable:

```yaml
- name: Tag with GitVersion
  uses: michielvha/gitversion-tag-action@v5
  with:
    configFilePath: 'gitversion.yml'
```

### 3. GitVersion Configuration (Optional)

If using GitVersion, create a `gitversion.yml` file in your repository root:

```yaml
# https://gitversion.net/docs/reference/configuration
# manually verify with `gitversion (/showconfig)`
# IMPORTANT: on initial onboarding comment out everything but workflow after first run you can put it back
workflow: GitHubFlow/v1
# Custom strategies - this differs from default

strategies:
  - MergeMessage
  - TaggedCommit
  - TrackReleaseBranches
  - VersionInBranchName
branches:
  main:
    regex: ^master$|^main$
    increment: Patch
    prevent-increment:
      of-merged-branch: true
    track-merge-target: false
    track-merge-message: true
    is-main-branch: true
    mode: ContinuousDeployment # also do it here
  release:
    # Custom release branch configuration
    regex: ^release/(?<BranchName>[0-9]+\.[0-9]+\.[0-9]+)$
    label: ''
    increment: None
    prevent-increment:
      when-current-commit-tagged: true
      of-merged-branch: true
    is-release-branch: true
    mode: ContinuousDeployment # do not use ContinuousDelivery, else it will increment the version with a suffix on each commit.
    source-branches:
      - main
```

### 4. Repository Permissions (Required for GitVersion)

If you're using GitVersion, ensure your workflow has the required permissions:

```yaml
permissions:
  contents: write  # For GitVersion tagging
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

If you encounter any issues or have questions, please [open an issue](https://github.com/michielvha/release-action/issues).
